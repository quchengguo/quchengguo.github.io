{"pages":[],"posts":[{"title":"hello","text":"搭建博客踩过的坑 github认证由密码更改为token方式（token记得保管好） 安装icarus主题之后，hexo s启动本地服务之后，打开localhost:4000是一堆代码 需要安装对应的依赖 npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 清除缓存，重新启动服务 切换next主题时遇到本地启动，打开localhost:4000是一堆代码。原因是hexo在5.0之后把swig给删除了需要自己手动安装npm i hexo-renderer-swig","link":"/2021/11/14/hello/"},{"title":"罗素：我的人生追求","text":"伯特兰·罗素：我的人生追求&nbsp;&nbsp;有三种简单而无比强烈的激情左右了我的一生：对爱的渴望，对知识的探索和对人类苦难的难以忍受的怜悯。这些激情像飓风，无处不在、反复无常地吹拂着我，吹过深重的苦海，濒与绝境。 &nbsp;&nbsp;我寻找爱，首先是因为它使人心醉神迷，这种陶醉是如此的美妙，使我愿意牺牲所有的余生去换取几个小时这样的欣喜。我寻找爱，还因为它能解除孤独，在可怕的孤独中，一颗颤抖的灵魂从世界的边缘看到冰冷、无底、死寂的深渊。最后，我寻找爱，还因为在爱的交融中，神秘而又具体入微地，我看到了圣贤和诗人们想象出的天堂的前景。这就是我所寻找的，而且，虽然对人生来说似乎过于美妙，这也是我终于找到了的。 &nbsp;以同样的激情我探索知识，我希望能够了解人类的心灵。我希望能够知道群星为何闪烁。我试图领悟毕达哥拉斯所景仰的数字的力量，它支配着此消彼长。仅在不大的程度上，我达到了此目的。 &nbsp;爱和知识，只要有可能，通向着天堂。但是怜悯总把我带回尘世。痛苦呼喊的回声回荡在我的内心。忍饥挨饿的孩子，惨遭压迫者摧残的受害者，被儿女们视为可憎的无助的老人，连同这整个充满了孤独、贫穷和痛苦的世界，使人类所应有的生活成了笑柄。我渴望能够减少邪恶，但是我无能为力，而且我自己也在忍受折磨。 &nbsp;这就是我的一生，我发现它值得一过。如果在给我一次机会，我会很高兴地再活它一次。","link":"/2021/12/20/%E7%BD%97%E7%B4%A0%EF%BC%9A%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E8%BF%BD%E6%B1%82/"},{"title":"icarus主题配置","text":"取消侧边栏不需要的挂件：在_config.icarus.yml的widgets元素中注释掉形如下面的代码 1234-position:type:xxx: 示例：注意-这个特殊字符也要注释掉否则hexo g的时候会报错 2.上传图片使用图床https://sm.ms/","link":"/2021/12/28/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"一切","text":"一切一切都是命运 一切都是烟云 一切都是没有结局的开始 一切都是稍纵即逝的追寻 一切欢乐都没有微笑 一切苦难都没有泪痕 一切语言都是重复 一切交往都是初逢 一切爱情都在心里 一切往事都在梦中 一切希望都带着注释 一切信仰都带着呻吟 一切爆发都有片刻的宁静 一切死亡都有冗长的回声","link":"/2022/02/16/%E4%B8%80%E5%88%87/"},{"title":"Hadoop-RPC","text":"1.简介远程过程调用RPC（Remote Procedure Call）是一个计算机通信协议，最大优势是隐藏（简化）复杂的网络编程，调用远程服务就像调用本地服务一样，一般的分布式系统都实现自己的一套PRC。 2.基于Hadoop RPC Writable 实现一个简易的RPCHadoop RPC框架中序列化机制实现有两种： Avro Writable 接口实现，简单易懂 Google Protobuf 跨语言实现，跨语言，高扩展，高效率 下面通过Avro Writable实现RPC主要有4步骤： 定义接口（协议） 实现1中的接口 编写服务端 编写客户端（在客户端中请求服务端） 1.定义接口（协议） 123456789101112131415package hadoop.common.rpc;/** * 通信协议 */public interface BussinessProtocol { void mkdir(String path); String getName(String name); /** * 通信协议版本号 */ long versionID = 345043000L;} 2.实现1中的接口 1234567891011121314151617package hadoop.common.rpc;/** * 通信协议具体实现 */public class BussinessProtocolImpl implements BussinessProtocol { @Override public void mkdir(String path) { System.out.println(&quot;成功创建文件夹&quot; + path); } @Override public String getName(String name) { System.out.println(&quot;成功打了招呼: hello &quot; + name); return &quot;bigdata server&quot;; }} 3.编写服务端 12345678910111213141516171819202122232425262728package hadoop.common.rpc;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.ipc.RPC;import org.apache.hadoop.ipc.Server;import java.io.IOException;/** * 服务端 */public class MyServer { public static void main(String[] args) { try { /** * 提供一个服务 */ Server server = new RPC.Builder(new Configuration()) .setProtocol(BussinessProtocol.class) .setInstance(new BussinessProtocolImpl()) .setBindAddress(&quot;localhost&quot;) .setPort(6789) .build(); server.start(); }catch (IOException e){ e.printStackTrace(); } }} 4.编写客户端并请求服务端 12345678910111213141516171819202122232425262728package hadoop.common.rpc;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.ipc.RPC;import java.io.IOException;import java.net.InetSocketAddress;/** * 客户端 */public class MyClient { public static void main(String[] args) { try { BussinessProtocol proxy = RPC.getProxy(BussinessProtocol.class, BussinessProtocol.versionID , new InetSocketAddress(&quot;localhost&quot;, 6789), new Configuration()); /** * 交互，客户端获取到代理对象之后，直接调用服务端的方法，完全感觉不到发送了网络请求 */ String rpcResult = proxy.getName(&quot;my client&quot;); System.out.println(&quot;从RPC服务端收到getName响应结果为:&quot; + rpcResult); } catch (IOException e) { e.printStackTrace(); } }} 5.测试，先启动Server，后启动Client，观测打印日志","link":"/2022/03/16/Hadoop-RPC/"}],"tags":[{"name":"人文","slug":"人文","link":"/tags/%E4%BA%BA%E6%96%87/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"}],"categories":[]}